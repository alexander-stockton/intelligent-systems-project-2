# intelligent-systems-project-2

LP  – Family relationship reasoning

ASP – Graph Coloring

### Alex's AI-Usage

`12/1/25` – used Gemini 3 Pro (Thinking) to generate a short family tree with 3 generations. Inference System is human-written save for 2 rules, KB is ai-generated.

`12/5/25` – used Gemini 3 Pro (Thinking) to generate documentation for how `family system.lp` fulfills project requirements. I then removed some unnecessary examples used in redundant explanation of said requirements.

# Part 1: SWI-Prolog Family relationship reasoning
> Mostly AI-generated by Gemini 3 Pro (Thinking) on 12/5/25
### 1. Define Clear Rules and Facts
The knowledge base strictly separates static data (facts) from logical derivations (rules), ensuring a clean and maintainable structure.

* **Facts:** The foundation of the system is built on unit clauses that define gender, marriage, and parenthood.
* **Rules:** Inference rules are defined to create complex relationships from these basic facts.

### 2. Implement Multiple Queries
The system supports a diverse range of queries, allowing users to verify facts or search for unknowns.

| Query Type | Predicate Example | Usage |
| :--- | :--- | :--- |
| **Existence** | `father/2` | `?- father(arthur, samuel).` (Returns `true` if the relationship holds) |
| **Search** | `sister/2` | `?- sister(X, samuel).` (Returns `X = julia`) |
| **Pattern Matching** | `grandparent/2` | `?- grandparent(arthur, X).` (Returns all grandchildren: `leo`, `sophie`) |

### 3. Include at Least One Recursive Relationship
To satisfy the requirement for recursion, the file includes a rule for **ancestry/descendance**, allowing the system to traverse multiple generations indefinitely.

* **Predicate:** `descendant(X, Z)`
* **Base Case:** Finds immediate children.
* **Recursive Step:** Finds children of descendants, linking generations together.

### 4. Document Your Predicates and Rules
The code is thoroughly documented using standard Prolog comments (`%`) to explain the intent of each block.

* **Section Headers:** Use of separators like `% ====================` and `% --- PARENTIAL RULES ---` to organize code.
* **Inline Explanations:** Each rule is preceded by a plain-English explanation of the relationship being defined.

### 5. Demonstrate Practical Use Cases
The defined rules allow for practical applications in genealogical research or logic problem solving:

* **Legal/Social Relationships:** The system can distinguish between blood relatives and in-laws using rules like `brother(X, Y)` (which checks `sibling_in_law`).
* **Extended Family Search:** The `cousin/2` rule enables finding non-immediate family members by tracing back to common grandparents:
* **Gender-Specific Roles:** The system automatically categorizes relatives into specific roles like `niece` vs `nephew` based on the underlying `male/1` and `female/1` facts.

# Part 2: clingo graph-coloring

instance.lp — graph definition (nodes + edges)
coloring.lp — coloring rules, constraints, and optimization

Problem Description: The goal is to solve a graph-coloring problem using ASP.
Each node in a graph must be assigned one color, and connected nodes cannot share the same color.
The program also tries to minimize the number of colors used, which is a common optimization in scheduling and map-coloring problems.

Solution Approach:
- The graph structure is written in instance.lp.

- coloring.lp assigns one color per node using a choice rule.

- A constraint blocks adjacent nodes from sharing the same color.

- A #minimize statement reduces the number of colors used in the final solution.

Sample Results:
Command (instlal clingo.exe before running):
clingo instance.lp coloring.lp

Reading from instance.lp ...
Solving...
Answer: 1
assign(b,green) assign(a,blue) assign(c,yellow) assign(d,red) assign(e,green) used(red) used(green) used(blue) used(yellow)
Optimization: 4
Answer: 2
assign(b,green) assign(a,blue) assign(c,yellow) assign(d,green) assign(e,blue) used(green) used(blue) used(yellow)
Optimization: 3
OPTIMUM FOUND

Models       : 2     
  Optimum    : yes
Optimization : 3
Calls        : 1
Time         : 0.011s (Solving: 0.01s 1st Model: 0.00s Unsat: 0.00s)
CPU Time     : 0.016s

Output explanation: The program solves at first with one option and tries to optimize it to use fewer colors, that is why we see the second answer set. 

### Exequiel AI usage

Asked chatgpt 5.1 to generate the instance.lp as an good example.

Asked it to fix an issue with the coloring when optimizing, fixed lines 10 and 13
